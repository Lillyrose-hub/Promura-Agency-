from app.simple_captions import router as caption_router
from fastapi import FastAPI, Request, Form, UploadFile, File, HTTPException, Depends, status
from fastapi.responses import HTMLResponse, JSONResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.middleware.cors import CORSMiddleware
from datetime import datetime
import os
import json
import uuid
from pathlib import Path
from typing import List, Optional, Dict
from pydantic import BaseModel
from app.onlysnarf_client import PromuraClient
from app.logging_system import logger
from app.content_library import content_library
from app.auth_system import user_manager, audit_logger, get_current_user, require_permission, get_optional_user
from app.burner_models import burner_manager, PRODUCTION_DEPLOYMENT_MEMORY

app = FastAPI()

# Add CORS middleware for API access
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, specify your domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Mount static files (CSS, JS, images)
app.mount("/static", StaticFiles(directory="app/static"), name="static")
templates = Jinja2Templates(directory="app/templates")

# Middleware for action tracking
@app.middleware("http")
async def track_actions(request: Request, call_next):
    """Track all user actions for audit logging"""
    # Get current user if authenticated
    user = await get_optional_user(request)

    # Log the action
    if user:
        audit_logger.log_action(
            username=user.get("username", "anonymous"),
            action="api_call",
            details=f"{request.method} {request.url.path}",
            ip_address=request.client.host if request.client else None,
            endpoint=request.url.path,
            method=request.method
        )

    response = await call_next(request)
    return response

# Initialize OnlySnarf client
promura = PromuraClient()

# Store scheduled posts and completed posts (in production, use a database)
scheduled_posts = []
completed_posts = []

# Caption library storage (in production, use a database)
#caption_library = []
#caption_data_file = Path("data/captions.json")
#
## Load saved captions on startup
#def load_captions():
#    global caption_library
#    if caption_data_file.exists():
#        try:
#            with open(caption_data_file, 'r') as f:
#                caption_library = json.load(f)
#            print(f"‚úÖ Loaded {len(caption_library)} captions from library")
#        except Exception as e:
#            print(f"‚ö†Ô∏è Could not load captions: {e}")
#            caption_library = []
#    else:
#        caption_library = []
#
#def save_captions():
#    try:
#        caption_data_file.parent.mkdir(exist_ok=True)
#        with open(caption_data_file, 'w') as f:
#            json.dump(caption_library, f, indent=2)
#        return True
#    except Exception as e:
#        print(f"‚ùå Could not save captions: {e}")
#        return False
#
#def add_caption_to_library(text: str, category: str = "General"):
#    """Add a caption to the library, avoiding duplicates"""
#    global caption_library
#
#    # Check if caption already exists
#    existing = next((c for c in caption_library if c["text"].strip().lower() == text.strip().lower()), None)
#
#    if not existing:
#        new_caption = {
#            "id": len(caption_library) + 1,
#            "text": text.strip(),
#            "category": category,
#            "created_at": datetime.now().isoformat(),
#            "used_count": 0
#        }
#        caption_library.append(new_caption)
#        save_captions()
#        return new_caption
#    else:
#        # Update use count if it exists
#        existing["used_count"] = existing.get("used_count", 0) + 1
#        save_captions()
#        return existing
#
## Load captions on startup
#load_captions()

# Real OnlyFans account for testing - Connected via OnlySnarf
models_data = [
    {
        "id": 1,
        "name": "purplefan420",  # Real OnlyFans account
        "avatar": "/static/models/default.jpg",
        "status": "active",
        "displayName": "Purple Fan",
        "connected": True  # Indicates real OnlySnarf connection
    }
]

# Get real profiles from OnlySnarf if available
try:
    real_profiles = promura.get_profiles()
    if real_profiles:
        models_data = []
        for idx, profile in enumerate(real_profiles, 1):
            models_data.append({
                "id": idx,
                "name": profile["username"],
                "avatar": "/static/models/default.jpg",
                "status": "active" if profile.get("active") else "inactive",
                "displayName": profile.get("display_name", profile["username"]),
                "connected": True
            })
        print(f"‚úÖ Loaded {len(models_data)} real OnlyFans profiles from OnlySnarf")
except Exception as e:
    print(f"‚ö†Ô∏è Using default profile: {e}")

# System status
system_status = {"online": True, "last_check": datetime.now()}

# Authentication Models
class LoginRequest(BaseModel):
    username: str
    password: str

class PasswordChangeRequest(BaseModel):
    old_password: str
    new_password: str

class PostEdit(BaseModel):
    content: str
    models: List[str]
    schedule_time: Optional[str]

# ==================== AUTHENTICATION ENDPOINTS ====================

@app.post("/api/auth/login")
async def login(login_data: LoginRequest):
    """Login endpoint"""
    user = user_manager.authenticate_user(login_data.username, login_data.password)

    if not user:
        # Log failed attempt
        audit_logger.log_action(
            username=login_data.username,
            action="login_failed",
            details="Invalid username or password"
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid username or password"
        )

    # Create access token
    token = user_manager.create_access_token(login_data.username)

    # Log successful login
    audit_logger.log_action(
        username=login_data.username,
        action="login",
        details="User logged in successfully"
    )

    return {
        "success": True,
        "access_token": token,
        "token_type": "bearer",
        "user": user
    }

@app.post("/api/auth/logout")
async def logout(current_user: Dict = Depends(get_current_user)):
    """Logout endpoint - logs the action"""
    audit_logger.log_action(
        username=current_user["username"],
        action="logout",
        details="User logged out"
    )
    return {"success": True, "message": "Logged out successfully"}

@app.get("/api/auth/me")
async def get_me(current_user: Dict = Depends(get_current_user)):
    """Get current user information"""
    return current_user

@app.post("/api/auth/change-password")
async def change_password(
    password_data: PasswordChangeRequest,
    current_user: Dict = Depends(get_current_user)
):
    """Change user password"""
    success = user_manager.change_password(
        current_user["username"],
        password_data.old_password,
        password_data.new_password
    )

    if not success:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid current password"
        )

    audit_logger.log_action(
        username=current_user["username"],
        action="password_change",
        details="Password changed successfully"
    )

    return {"success": True, "message": "Password changed successfully"}

@app.get("/api/auth/users")
async def list_users(current_user: Dict = Depends(require_permission("all"))):
    """List all users - requires owner permission"""
    return user_manager.list_users()

@app.get("/api/audit/logs")
async def get_audit_logs(
    limit: int = 100,
    current_user: Dict = Depends(require_permission("all"))
):
    """Get audit logs - requires owner permission"""
    return audit_logger.get_recent_logs(limit)

@app.get("/api/audit/user/{username}")
async def get_user_logs(
    username: str,
    limit: int = 100,
    current_user: Dict = Depends(require_permission("all"))
):
    """Get audit logs for specific user - requires owner permission"""
    return audit_logger.get_user_logs(username, limit)

# ==================== TEAM MANAGEMENT ENDPOINTS ====================

class AddUserRequest(BaseModel):
    username: str
    email: str
    password: str
    full_name: str
    role: str

@app.post("/api/team/add-user")
async def add_user(
    user_data: AddUserRequest,
    current_user: Dict = Depends(require_permission("all"))
):
    """Add a new team member - requires owner permission"""
    # Check if username already exists
    if user_manager.get_user(user_data.username):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Username {user_data.username} already exists"
        )

    # Get permissions based on role
    permission_map = {
        "owner": ["all"],
        "manager": ["schedule", "view", "edit", "queue", "captions", "metrics"],
        "assistant": ["view", "schedule", "captions"]
    }
    permissions = permission_map.get(user_data.role, ["view"])

    # Add user to the system
    user_dict = {
        "password": user_manager._hash_password(user_data.password),
        "role": user_data.role,
        "permissions": permissions,
        "email": user_data.email,
        "full_name": user_data.full_name,
        "created_at": datetime.now().isoformat(),
        "created_by": current_user["username"],
        "active": True
    }

    # Add to users database
    user_manager.users[user_data.username] = user_dict
    user_manager._save_users()

    # Log the action
    audit_logger.log_action(
        username=current_user["username"],
        action="add_user",
        details=f"Added user {user_data.username} as {user_data.role}"
    )

    return {
        "success": True,
        "message": f"User {user_data.username} added successfully"
    }

@app.get("/api/team/users")
async def get_team_users(current_user: Dict = Depends(require_permission("all"))):
    """Get all team members - requires owner permission"""
    users_list = []
    for username, user_data in user_manager.users.items():
        users_list.append({
            "username": username,
            "role": user_data.get("role", "unknown"),
            "email": user_data.get("email", ""),
            "full_name": user_data.get("full_name", username),
            "permissions": user_data.get("permissions", []),
            "created_at": user_data.get("created_at", "Unknown"),
            "created_by": user_data.get("created_by", "System"),
            "active": user_data.get("active", True)
        })

    # Sort by role (owner first, then manager, then assistant)
    role_order = {"owner": 0, "manager": 1, "assistant": 2}
    users_list.sort(key=lambda x: (role_order.get(x["role"], 3), x["username"]))

    return users_list

@app.delete("/api/team/delete-user/{username}")
async def delete_user(
    username: str,
    current_user: Dict = Depends(require_permission("all"))
):
    """Delete a team member - requires owner permission"""
    # Prevent self-deletion
    if username == current_user["username"]:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="You cannot delete your own account"
        )

    # Check if user exists
    if username not in user_manager.users:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"User {username} not found"
        )

    # Prevent deleting other owners
    user = user_manager.users[username]
    if user.get("role") == "owner":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Cannot delete other owners"
        )

    # Delete the user
    del user_manager.users[username]
    user_manager._save_users()

    # Log the action
    audit_logger.log_action(
        username=current_user["username"],
        action="delete_user",
        details=f"Deleted user {username}"
    )

    return {
        "success": True,
        "message": f"User {username} has been removed"
    }

@app.put("/api/team/update-user/{username}")
async def update_user(
    username: str,
    updates: Dict,
    current_user: Dict = Depends(require_permission("all"))
):
    """Update a team member - requires owner permission"""
    # Check if user exists
    if username not in user_manager.users:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"User {username} not found"
        )

    # Update user
    success = user_manager.update_user(username, updates)

    if success:
        # Log the action
        audit_logger.log_action(
            username=current_user["username"],
            action="update_user",
            details=f"Updated user {username}"
        )

        return {
            "success": True,
            "message": f"User {username} updated successfully"
        }
    else:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Failed to update user"
        )

# Owner creation model
class OwnerCreateRequest(BaseModel):
    username: str
    email: str
    password: str
    full_name: str
    role: str = "owner"
    permission_level: str  # 'full', 'content', or 'financial'

@app.post("/api/team/owners")
async def create_owner(
    owner_data: OwnerCreateRequest,
    current_user: Dict = Depends(require_permission("all"))
):
    """Create a new owner account - requires existing owner permission"""
    # Verify current user is an owner
    if current_user.get("role") != "owner":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only owners can create new owner accounts"
        )

    # Check if username already exists
    if user_manager.get_user(owner_data.username):
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Username {owner_data.username} already exists"
        )

    # Set permissions based on permission level
    if owner_data.permission_level == "full":
        permissions = ["all"]
    elif owner_data.permission_level == "content":
        permissions = ["schedule", "view", "edit", "queue", "captions", "media", "content_management"]
    elif owner_data.permission_level == "financial":
        permissions = ["view", "metrics", "financial", "reports", "analytics", "revenue_management"]
    else:
        permissions = ["all"]  # Default to full access

    # Create the new owner
    success = user_manager.add_user(
        username=owner_data.username,
        password=owner_data.password,
        role="owner",
        email=owner_data.email,
        full_name=owner_data.full_name,
        permissions=permissions,
        created_by=current_user["username"]
    )

    if success:
        # Log the action
        audit_logger.log_action(
            username=current_user["username"],
            action="create_owner",
            details=f"Created new owner account: {owner_data.username} with {owner_data.permission_level} permissions"
        )

        return {
            "success": True,
            "message": f"Owner account created successfully for {owner_data.full_name}",
            "owner": {
                "username": owner_data.username,
                "email": owner_data.email,
                "full_name": owner_data.full_name,
                "role": "owner",
                "permissions": permissions,
                "permission_level": owner_data.permission_level
            }
        }
    else:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to create owner account"
        )

# ==================== BURNER MODEL MANAGEMENT ====================

@app.get("/api/models")
async def get_all_models(current_user: Dict = Depends(get_current_user)):
    """Get all burner test models (TEMPORARY - WILL BE REPLACED WITH REAL DATA)"""
    models = burner_manager.get_all_models()

    # Add warning to response
    return {
        "warning": "‚ö†Ô∏è THESE ARE BURNER TEST MODELS - NOT REAL ACCOUNTS",
        "models": models,
        "count": len(models),
        "cleanup_required": True,
        "production_ready": False
    }

@app.get("/api/models/search")
async def search_models(query: str, current_user: Dict = Depends(get_current_user)):
    """Search burner models"""
    results = burner_manager.search_models(query)
    return {
        "query": query,
        "results": results,
        "count": len(results)
    }

@app.get("/api/models/{model_id}")
async def get_model_details(model_id: str, current_user: Dict = Depends(get_current_user)):
    """Get specific model details"""
    model = burner_manager.get_model_by_id(model_id)
    if not model:
        raise HTTPException(status_code=404, detail="Model not found")
    return model

@app.post("/api/models/cleanup")
async def cleanup_burner_models(current_user: Dict = Depends(require_permission("all"))):
    """üö® EMERGENCY CLEANUP - Remove all burner test data"""
    from app.utils.burner_cleanup import emergency_burner_cleanup

    # Log the cleanup action
    audit_logger.log_action(
        username=current_user["username"],
        action="burner_cleanup",
        details="Removed all BURNER test models for production deployment"
    )

    result = emergency_burner_cleanup()
    return {
        "success": True,
        "message": "All burner test data removed successfully",
        "result": result
    }

@app.get("/api/models/check-burners")
async def check_burner_status():
    """Check if burner test data exists"""
    from app.utils.burner_cleanup import check_for_burner_data

    has_burners = check_for_burner_data()
    return {
        "has_burner_data": has_burners,
        "memory": PRODUCTION_DEPLOYMENT_MEMORY,
        "reminder": "These are temporary test accounts" if has_burners else "System clean"
    }

# ==================== DASHBOARD GREETING API ====================

def get_role_appropriate_messages(user_role: str):
    """Get motivational messages appropriate for each user role"""
    base_messages = [
        "Ready to make today amazing!",
        "Let's create some magic today!",
        "You're doing incredible work!",
        "Making a difference, one action at a time!",
        "Today is full of opportunities!"
    ]

    role_specific_messages = {
        "owner": [
            "Leading the team to success!",
            "System performance looking great!",
            "Your leadership inspires everyone!",
            "Building an empire, one day at a time!",
            "Excellence is your standard!"
        ],
        "manager": [
            "Your team is crushing it today!",
            "Great coordination on the models!",
            "Managing like a pro!",
            "Team synergy at its finest!",
            "Orchestrating success brilliantly!"
        ],
        "assistant": [
            "Your dedication shines through!",
            "Making connections that matter!",
            "Your energy drives results!",
            "Creating value with every interaction!",
            "Customer satisfaction champion!"
        ],
        "support": [
            "Keeping everything running smoothly!",
            "Your support makes all the difference!",
            "System stability at its best!",
            "Technical excellence in action!",
            "Problem-solving superstar!"
        ]
    }

    return base_messages + role_specific_messages.get(user_role.lower(), [])

def get_role_dashboard_stats(user_role: str, username: str):
    """Get role-appropriate quick stats for the greeting badge"""
    import random

    # Sample data - in production this would query your database
    if user_role.lower() == "owner":
        return {
            "active_models": random.randint(10, 25),
            "total_revenue": random.randint(5000, 15000),
            "team_online": random.randint(5, 15)
        }
    elif user_role.lower() == "manager":
        return {
            "managed_models": random.randint(5, 12),
            "team_performance": random.randint(75, 98),
            "revenue_today": random.randint(1000, 5000)
        }
    elif user_role.lower() == "assistant":
        return {
            "assigned_models": random.randint(2, 5),
            "active_conversations": random.randint(5, 30),
            "response_rate": random.randint(85, 99)
        }
    else:  # support or generic user
        return {
            "system_health": random.randint(95, 100),
            "active_users": random.randint(10, 30),
            "uptime_percentage": 99.9
        }

@app.get("/api/dashboard/greeting")
async def get_personalized_greeting(current_user: Dict = Depends(get_current_user)):
    """Generate smart, contextual greeting with motivational messages"""
    from datetime import datetime
    from app.motivational_messages import BrandMotivationalMessageSystem

    # Initialize the message system
    motivational_system = BrandMotivationalMessageSystem()

    # Extract first name from full name or use username
    full_name = current_user.get("full_name", "")
    if full_name:
        # Extract the first word of the full name
        user_first_name = full_name.split()[0].split("(")[0].strip()  # Handle names like "Lea (Owner)"
    else:
        # Use the username with proper casing as fallback
        username = current_user.get("username", "Team Member")
        user_first_name = username.capitalize() if username else "Team Member"

    user_role = current_user.get("role", "user")
    username = current_user.get("username", "")

    # Time-based greeting
    current_hour = datetime.now().hour
    if current_hour < 12:
        time_greeting = "Good morning"
    elif current_hour < 18:
        time_greeting = "Good afternoon"
    else:
        time_greeting = "Good evening"

    # Get contextual motivational message
    context = motivational_system.get_current_context()
    motivational_data = motivational_system.get_contextual_message(user_role, context)

    # Get role-appropriate stats
    dashboard_stats = get_role_dashboard_stats(user_role, username)

    return {
        "greeting": f"{time_greeting}, {user_first_name}",
        "motivational_message": motivational_data["message"],
        "message_category": motivational_data["category"],
        "message_svg_icon": motivational_data["svg_icon"],
        "message_color": motivational_data["color"],
        "category_display_name": motivational_system.get_category_display_name(motivational_data.get("category", "quick_wins")),
        "user_first_name": user_first_name,
        "user_role": user_role,
        "dashboard_stats": dashboard_stats,
        "context": motivational_data.get("context", {})
    }

# ==================== MAIN APPLICATION ROUTES ====================

@app.get("/login", response_class=HTMLResponse)
async def login_page(request: Request):
    """Login page"""
    return templates.TemplateResponse("login.html", {"request": request})

@app.get("/team", response_class=HTMLResponse)
async def team_management_page(request: Request):
    """Team management page"""
    return templates.TemplateResponse("team_management.html", {"request": request})

@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    """Main dashboard page - will check authentication via JavaScript"""
    return templates.TemplateResponse("index.html", {
        "request": request,
        "models": models_data
    })

@app.get("/api/models")
async def get_models():
    """Get all available models"""
    return models_data

@app.get("/api/queue")
async def get_queue():
    """Get all scheduled posts"""
    return {"queue": scheduled_posts, "history": completed_posts}

@app.get("/api/status")
async def get_status():
    """Get system status"""
    return {
        "online": system_status["online"],
        "last_check": system_status["last_check"].isoformat(),
        "queue_count": len(scheduled_posts),
        "completed_count": len(completed_posts)
    }

@app.get("/api/history")
async def get_history():
    """Get completed posts history"""
    return completed_posts

# ==================== CAPTION LIBRARY ENDPOINTS ====================

# Removed duplicate endpoint - using the one with caption_manager below

@app.post("/api/captions")
async def add_caption(
    text: str = Form(...),
    category: str = Form("General"),
    current_user: Dict = Depends(get_current_user)
):
    """Add a new caption to the library"""
    new_caption = add_caption_to_library(text, category)

    # Log the action
    audit_logger.log_action(
        username=current_user["username"],
        action="add_caption",
        details=f"Added caption to library: {text[:50]}..."
    )

    return {
        "success": True,
        "caption": new_caption,
        "message": "Caption added successfully"
    }

@app.delete("/api/captions/{caption_id}")
async def delete_caption(
    caption_id: int,
    current_user: Dict = Depends(get_current_user)
):
    """Delete a caption from the library"""
    global caption_library

    caption = next((c for c in caption_library if c.get("id") == caption_id), None)

    if not caption:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Caption with id {caption_id} not found"
        )

    caption_library = [c for c in caption_library if c.get("id") != caption_id]
    save_captions()

    # Log the action
    audit_logger.log_action(
        username=current_user["username"],
        action="delete_caption",
        details=f"Deleted caption: {caption['text'][:50]}..."
    )

    return {
        "success": True,
        "message": "Caption deleted successfully"
    }

@app.put("/api/captions/{caption_id}/use")
async def use_caption(caption_id: int):
    """Mark a caption as used (increment use count)"""
    caption = next((c for c in caption_library if c.get("id") == caption_id), None)

    if caption:
        caption["used_count"] = caption.get("used_count", 0) + 1
        save_captions()
        return {"success": True, "used_count": caption["used_count"]}

    raise HTTPException(
        status_code=status.HTTP_404_NOT_FOUND,
        detail=f"Caption with id {caption_id} not found"
    )

@app.post("/schedule-post")
async def schedule_post(
    request: Request,
    content: str = Form(...),
    models: str = Form("[]"),  # JSON string of selected models
    schedule_time: str = Form(None),
    library_media_ids: str = Form(None),  # JSON string of library media IDs
    media_files: list[UploadFile] = File([]),
    current_user: Dict = Depends(require_permission("schedule"))
):
    """Handle post scheduling with model selection and mixed media"""
    try:
        # Parse selected models
        selected_models = json.loads(models) if models else []

        # Parse library media IDs
        library_ids = json.loads(library_media_ids) if library_media_ids else []

        # Generate unique ID
        post_id = str(uuid.uuid4())

        # Collect all media files
        all_media_files = []

        # Add library media files
        if library_ids:
            for media_id in library_ids:
                media_item = content_library.get_media_by_id(media_id)
                if media_item:
                    # Get the actual file path
                    media_type = "images" if media_item["type"] == "image" else "videos"
                    file_path = Path("static/library") / media_type / "original" / media_item["filename"]
                    all_media_files.append({
                        "path": str(file_path),
                        "source": "library",
                        "id": media_id,
                        "url": media_item["url"]
                    })
                    # Track usage
                    content_library.use_media(media_id)
                    logger.log(f"Library media used: {media_id} in post {post_id}")

        # Handle new file uploads
        saved_files = []
        upload_dir = Path("uploads")
        upload_dir.mkdir(exist_ok=True)

        for file in media_files:
            if file.filename:
                timestamp = datetime.now().timestamp()
                file_path = upload_dir / f"{timestamp}_{file.filename}"
                with open(file_path, "wb") as buffer:
                    file_content = await file.read()
                    buffer.write(file_content)
                saved_files.append(str(file_path))
                all_media_files.append({
                    "path": str(file_path),
                    "source": "upload",
                    "filename": file.filename
                })

        # Create post data with enhanced structure
        post_data = {
            "id": post_id,
            "content": content,
            "models": selected_models,
            "media_files": all_media_files,
            "library_media_count": len(library_ids),
            "upload_media_count": len(saved_files),
            "schedule_time": schedule_time,
            "timestamp": datetime.now().isoformat(),
            "status": "scheduled" if schedule_time else "posting",
            "completed_at": None
        }

        # Automatically save caption to library for reuse
        if content and content.strip():
            add_caption_to_library(content, category="General")

        # Add to scheduled posts
        scheduled_posts.append(post_data)

        # Store success trigger for quick win message
        request.session["post_success"] = True

        # If no schedule time, post immediately
        if not schedule_time:
            try:
                # Get all file paths for posting
                file_paths = [item["path"] for item in all_media_files]

                # Simulate posting
                result = promura.schedule_post(content, file_paths)
                post_data["status"] = "completed"
                post_data["completed_at"] = datetime.now().isoformat()

                # Move to completed posts
                scheduled_posts.remove(post_data)
                completed_posts.insert(0, post_data)

                total_media = len(all_media_files)
                media_info = f" with {total_media} media file{'s' if total_media != 1 else ''}" if total_media > 0 else ""
                message = f"‚úÖ Post published successfully to {len(selected_models)} models{media_info}!"
            except Exception as e:
                post_data["status"] = "failed"
                message = f"‚ùå Post failed: {str(e)}"
        else:
            total_media = len(all_media_files)
            media_info = f" with {total_media} media file{'s' if total_media != 1 else ''}" if total_media > 0 else ""
            message = f"‚úÖ Post scheduled for {schedule_time} to {len(selected_models)} models{media_info}!"

        return JSONResponse({
            "success": True,
            "message": message,
            "post_id": post_id
        })

    except Exception as e:
        return JSONResponse({
            "success": False,
            "message": f"‚ùå Error: {str(e)}"
        }, status_code=400)

@app.post("/api/queue/{post_id}/cancel")
async def cancel_post(post_id: str, current_user: Dict = Depends(require_permission("queue"))):
    """Cancel a scheduled post"""
    for post in scheduled_posts:
        if post["id"] == post_id:
            scheduled_posts.remove(post)
            return {"success": True, "message": "Post cancelled successfully"}

    raise HTTPException(status_code=404, detail="Post not found")

@app.post("/api/queue/{post_id}/edit")
async def edit_post(post_id: str, post_edit: PostEdit):
    """Edit a scheduled post"""
    for post in scheduled_posts:
        if post["id"] == post_id:
            post["content"] = post_edit.content
            post["models"] = post_edit.models
            if post_edit.schedule_time:
                post["schedule_time"] = post_edit.schedule_time
            return {"success": True, "message": "Post updated successfully"}

    raise HTTPException(status_code=404, detail="Post not found")

@app.delete("/api/queue/{post_id}")
async def delete_post(post_id: str):
    """Delete a scheduled post"""
    for post in scheduled_posts:
        if post["id"] == post_id:
            # Delete associated files
            for file_path in post.get("media_files", []):
                if os.path.exists(file_path):
                    os.remove(file_path)

            scheduled_posts.remove(post)
            return {"success": True, "message": "Post deleted successfully"}

    raise HTTPException(status_code=404, detail="Post not found")

@app.get("/queue", response_class=HTMLResponse)
async def view_queue(request: Request):
    """Enhanced queue view page"""
    return templates.TemplateResponse("queue.html", {
        "request": request,
        "scheduled_posts": scheduled_posts,
        "completed_posts": completed_posts
    })

@app.get("/metrics", response_class=HTMLResponse)
async def view_metrics(request: Request):
    """Metrics dashboard page"""
    return templates.TemplateResponse("metrics.html", {
        "request": request
    })

@app.get("/status")
async def check_status():
    """Check system status - YOUR EXISTING CODE"""
    status = promura.test_connection()
    return {
        "dashboard": "PROMURA Dashboard Online",
        "onlysnarf_integration": status,
        "scheduled_posts": len(scheduled_posts)
    }

@app.get("/api/metrics")
async def get_metrics():
    """Get comprehensive system metrics for dashboard display"""
    metrics = logger.get_dashboard_metrics()

    # Add additional real-time information
    metrics["system"] = {
        "online": system_status["online"],
        "last_check": system_status["last_check"].isoformat(),
        "scheduled_posts": len(scheduled_posts),
        "completed_posts": len(completed_posts)
    }

    return metrics

@app.get("/api/logs/export")
async def export_logs():
    """Export all logs to a file"""
    export_file = logger.export_logs()
    return {
        "success": True,
        "message": f"Logs exported successfully",
        "file": str(export_file)
    }

# Content Library API Endpoints
@app.get("/api/library")
async def get_content_library(media_type: Optional[str] = None, tags: Optional[str] = None):
    """Get all media in content library"""
    tags_list = tags.split(",") if tags else None
    media = content_library.get_all_media(media_type, tags_list)
    return media

@app.get("/api/library/search")
async def search_library(q: str):
    """Search content library"""
    results = content_library.search_media(q)
    return results

@app.get("/api/library/stats")
async def get_library_stats():
    """Get library statistics"""
    stats = content_library.get_statistics()
    return stats

@app.post("/api/library/upload")
async def upload_to_library(file: UploadFile = File(...), tags: str = "", description: str = ""):
    """Upload new media to library"""
    try:
        # Read file data
        file_data = await file.read()

        # Parse tags
        tags_list = [tag.strip() for tag in tags.split(",") if tag.strip()] if tags else []

        # Add to library
        media_entry = content_library.add_media(
            file_data=file_data,
            filename=file.filename,
            tags=tags_list,
            description=description
        )

        logger.log(f"Library upload: {file.filename} (ID: {media_entry['id']})")

        return {"success": True, "media": media_entry}
    except Exception as e:
        logger.error(f"Library upload failed: {str(e)}")
        raise HTTPException(status_code=400, detail=str(e))

@app.post("/api/library/{media_id}/use")
async def use_media_in_post(media_id: str):
    """Increment usage count for media"""
    if content_library.use_media(media_id):
        logger.log(f"Library media incremented: {media_id}")
        return {"success": True}
    else:
        raise HTTPException(status_code=404, detail="Media not found")

@app.delete("/api/library/{media_id}")
async def delete_from_library(media_id: str):
    """Remove media from library"""
    if content_library.delete_media(media_id):
        logger.log(f"Library media deleted: {media_id}")
        return {"success": True}
    else:
        raise HTTPException(status_code=404, detail="Media not found")

# Caption Library Routes
@app.get("/captions", response_class=HTMLResponse)
async def caption_library(request: Request):
    """Caption Library page"""
    return templates.TemplateResponse("captions.html", {
        "request": request
    })

@app.get("/captions-compact", response_class=HTMLResponse)
async def caption_library_compact(request: Request):
    """Compact Caption Library page"""
    return templates.TemplateResponse("captions_compact.html", {
        "request": request
    })

@app.post("/api/captions/upload")
async def upload_captions(file: UploadFile = File(...)):
    """Upload Excel file with captions"""
    try:
        # Read file content
        contents = await file.read()

        # Process the Excel file using CaptionManager
        result = caption_manager.process_excel_file(contents, file.filename)

        if result["success"]:
            print(f"Caption upload: {file.filename} - {result['message']}")
            return JSONResponse({
                "success": True,
                "message": result["message"],
                "captions": result["captions"],
                "summary": result.get("summary", {})
            })
        else:
            logger.log_error("Caption Upload", f"Caption upload failed: {result['message']}")
            return JSONResponse({
                "success": False,
                "message": result["message"]
            }, status_code=400)

    except Exception as e:
        logger.log_error("Caption Upload", f"Caption upload error: {str(e)}")
        return JSONResponse({
            "success": False,
            "message": f"Error processing file: {str(e)}"
        }, status_code=400)

@app.post("/api/captions/replace-all")
async def replace_all_captions(file: UploadFile = File(...)):
    """Replace all existing captions with new Excel file"""
    try:
        # 1. DELETE all existing captions from database
        caption_manager.clear_all_captions()
        print("Cleared all existing captions for replacement")

        # 2. Read and PROCESS new Excel file
        contents = await file.read()
        result = caption_manager.process_excel_file(contents, file.filename)

        if result["success"]:
            print(f"Caption replacement: {file.filename} - {result['message']}")
            return JSONResponse({
                "success": True,
                "message": f"All captions replaced. {result['message']}",
                "captions": result["captions"],
                "summary": result.get("summary", {})
            })
        else:
            logger.log_error("Caption Upload", f"Caption replacement failed: {result['message']}")
            return JSONResponse({
                "success": False,
                "message": result["message"]
            }, status_code=400)
# REMOVED BROKEN CAPTION MANAGER ROUTE
# REMOVED BROKEN CAPTION MANAGER ROUTE
# REMOVED BROKEN CAPTION MANAGER ROUTE
# REMOVED BROKEN CAPTION MANAGER ROUTE
# REMOVED BROKEN CAPTION MANAGER ROUTE
# REMOVED BROKEN CAPTION MANAGER ROUTE
# REMOVED BROKEN CAPTION MANAGER ROUTE
# REMOVED BROKEN CAPTION MANAGER ROUTE
# REMOVED BROKEN CAPTION MANAGER ROUTE

@app.post("/api/captions/{caption_id}/use")
async def use_caption(caption_id: str):
    """Track caption usage"""
    if caption_manager.increment_usage(caption_id):
        logger.log(f"Caption used: {caption_id}")
        return {"success": True}
    else:
        raise HTTPException(status_code=404, detail="Caption not found")

@app.post("/api/copy-caption")
async def copy_caption(caption_id: str = Form(...)):
    """Track when a caption is copied to clipboard"""
    caption = caption_manager.get_caption_by_id(caption_id)
    if caption:
        caption_manager.increment_usage(caption_id)
        logger.log(f"Caption copied: {caption_id}")
        return {
            "success": True,
            "message": "Caption copied and usage tracked",
            "caption": caption
        }
    else:
        raise HTTPException(status_code=404, detail="Caption not found")

@app.delete("/api/captions/{caption_id}")
async def delete_caption(caption_id: str):
    """Delete a caption"""
    if caption_manager.delete_caption(caption_id):
        logger.log(f"Caption deleted: {caption_id}")
        return {"success": True}
    else:
        raise HTTPException(status_code=404, detail="Caption not found")

@app.post("/api/captions/add-single")
async def add_single_caption(text: str = Form(...), category: str = Form(...)):
    """Add a single caption manually"""
    try:
        new_caption = caption_manager.add_single_caption(text, category)
        logger.log(f"Caption added: {new_caption['id']}")
        return {
            "success": True,
            "caption": new_caption,
            "message": "Caption added successfully"
        }
    except Exception as e:
        logger.error(f"Error adding caption: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/api/captions/{caption_id}")
async def update_caption(caption_id: str, text: Optional[str] = Form(None), category: Optional[str] = Form(None)):
    """Update an existing caption"""
    if caption_manager.update_caption(caption_id, text, category):
        logger.log(f"Caption updated: {caption_id}")
        return {"success": True, "message": "Caption updated"}
    else:
        raise HTTPException(status_code=404, detail="Caption not found")

@app.get("/api/captions/popular")
async def get_popular_captions(limit: int = 10):
    """Get the most popular captions"""
    return caption_manager.get_popular_captions(limit)

@app.get("/api/captions/recent")
async def get_recent_captions(limit: int = 10):
    """Get recently added captions"""
    return caption_manager.get_recent_captions(limit)

@app.get("/api/captions/stats")
async def get_caption_stats():
    """Get caption library statistics"""
    return caption_manager.get_statistics()

@app.post("/api/captions/clear")
async def clear_all_captions():
    """Clear all captions from the library"""
    caption_manager.clear_all_captions()
    print("All captions cleared")
    return {"success": True, "message": "All captions cleared"}

@app.get("/api/captions/export")
async def export_captions():
    """Export all captions to Excel file"""
    try:
        export_path = Path("exports/captions_export.xlsx")
        export_path.parent.mkdir(exist_ok=True)

        if caption_manager.export_to_excel(str(export_path)):
            logger.log("Captions exported to Excel")
            return FileResponse(
                path=str(export_path),
                filename=f"captions_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx",
                media_type="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
        else:
            raise HTTPException(status_code=400, detail="No captions to export")
    except Exception as e:
        logger.error(f"Export failed: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

app.include_router(caption_router, prefix="/api")
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
from app.simple_captions import router as caption_router

# Simple captions route using Excel file
@app.get("/api/captions")
async def get_all_captions():
    import pandas as pd
    df = pd.read_excel('Caption Library NEW.xlsx')
    return df.to_dict('records')

@app.get("/api/captions/categories")
async def get_caption_categories():
    import pandas as pd
    df = pd.read_excel('Caption Library NEW.xlsx')
    return df['Categories'].unique().tolist()

# Clean captions routes using Excel file
@app.get("/api/captions")
async def get_all_captions():
    import pandas as pd
    df = pd.read_excel('Caption Library NEW.xlsx')
    return df.to_dict('records')

@app.get("/api/captions/categories")
async def get_caption_categories():
    import pandas as pd
    df = pd.read_excel('Caption Library NEW.xlsx')
    return df['Categories'].unique().tolist()
        return JSONResponse({
            "success": True,
            "message": "Content scheduled successfully",
            "scheduled_time": schedule_time
        })
    except Exception as e:
        logger.error(f"Scheduling error: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

# Clean captions routes using Excel file
@app.get("/api/captions")
async def get_all_captions():
    import pandas as pd
    df = pd.read_excel('Caption Library NEW.xlsx')
    return df.to_dict('records')

@app.get("/api/captions/categories")
async def get_caption_categories():
    import pandas as pd
    df = pd.read_excel('Caption Library NEW.xlsx')
    return df['Categories'].unique().tolist()
